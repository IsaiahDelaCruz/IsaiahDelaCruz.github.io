---
layout: essay
type: essay
title: "More Than Just Code"
# All dates must be YYYY-MM-DD format!
date: 2025-05-16
published: true
labels:
  - Computer Science
---

When people hear "software engineering," they often picture someone just writing lines of code that eventually turns into a working app or website. And if they know you took a class in web application development, they'll probably assume that’s all you did. Create pretty interfaces and wire up some buttons. 

But after actually taking this course, I’ve realized it’s way more than that. Yes, I learned how to build web apps. But more importantly, I learned how to think like a software engineer and that’s a mindset that applies way beyond the browser. To prove it, let’s break down some of the concepts we explored that go way deeper than just web development: Agile Project Management, Configuration Management, and Open Source Software Development.


## The Good Practice

In this course, we were introduced to a project management method called Issue Driven Project Management (IDPM), which is a style of Agile Project Management. If you’re unfamiliar, Agile is an iterative way of building software. Instead of planning everything upfront, you break work into small tasks, execute quickly, and keep refining based on feedback. It’s flexible, fast, and human-centered.

Issue Driven Project Management fits into Agile by assigning each unit of work like fixing a bug or adding a feature as a GitHub issue. These issues are then directly tied to commits, branches, and pull requests. The point is to make each task visible, trackable, and linked to actual code changes. It forces you to keep things organized, stay on track, and clearly define what you’re working on and why.

What makes IDPM powerful is that it doesn’t only apply to web apps. Imagine you’re building a game engine or a mobile app or even writing a textbook collaboratively. The concept of tying every change to a well-defined issue and keeping your project modular and transparent is useful anywhere. You get clarity, accountability, and structure, all while still moving fast.

## The Good Structure

Now let’s talk about Configuration Management. Sounds technical and boring, but it’s anything but.

Configuration Management is all about managing changes to your software—keeping track of code, dependencies, settings, environments, and more. Ever had your code work on one machine but break on another? That’s what configuration management solves. It ensures that you, your team, and even future-you can reproduce, debug, and scale your software reliably. 

This is done using tools like version control systems (e.g., Git), package managers (like npm or pip), and environment managers (like Docker). These tools might seem like extras when you’re coding solo, but in any team environment or any long-term project they’re essential. They bring order to chaos.

If theres one big thing I took away from this class was that a piece of code does NOT work for everyone all the time. Understanding and becoming familiar with the concept of having to worry about compatibility with other users is both a burden and hidden gem. It forced me to understand that I should code like im coding 
for the world.

And again, this concept isn’t tied to web apps. Whether you're training a machine learning model or deploying a backend service, configuration management is how you ensure things work consistently. Without it, you're just hoping your code runs. 

## So is it just about Web Dev?

Nope. Web development was just the playground. What I really learned is how to work with people, organize complexity, and build systems that are meant to last.

Agile showed me how to manage progress.
Configuration Management showed me how to manage complexity.
Open Source showed me how to manage people and responsibility.

Put it all together and that’s software engineering.

